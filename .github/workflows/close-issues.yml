name: Close Unauthorized Issues

on:
  workflow_dispatch:
  issues:
    types: [opened]
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight, in case issues were missed due missing workflow runs

jobs:
  close-unauthorized-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      # XXX: This *could* be done in Bash by abusing GitHub's own tool to interact with its API
      # but that's too much of a hack, and we'll be adding a layer of abstraction. github-script
      # is a workflow that eases interaction with GitHub API in the workflow run context.
      - name: "Close 'unauthorized' issues"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ALLOWED_USERS = ['vaxerki', 'fufexan', 'NotAShelf'];
            const CLOSING_COMMENT = 'Users are no longer allowed to open issues themselves, please open a discussion instead.\n\nPlease see the [wiki](https://wiki.hyprland.org/Contributing-and-Debugging/Issue-Guidelines/) on why this is the case.\n\nWe are volunteers, and we need your cooperation to make the best software we can. Thank you for understanding! ❤️\n\n[Open a discussion here](https://github.com/hyprwm/Hyprland/discussions)';

            async function processIssues() {
              let issuesToProcess = [];

              // Get issues based on trigger type
              if (context.eventName === 'issues' && context.payload.action === 'opened') {
                // Only process the newly created issue
                issuesToProcess = [{
                  number: context.payload.issue.number,
                  user: { login: context.payload.issue.user.login }
                }];
              } else {
                // Get all open issues (for scheduled or manual runs)
                const { data: openIssues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100
                });

                issuesToProcess = openIssues;
              }

              for (const issue of issuesToProcess) {
                try {
                  // Skip issues created by allowed users
                  if (ALLOWED_USERS.includes(issue.user.login)) {
                    console.log(`Issue #${issue.number} - Created by authorized user ${issue.user.login}`);
                    continue;
                  }

                  // Get full issue data
                  const { data: fullIssue } = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number
                  });

                  // Skip pull requests (the issues API also returns PRs)
                  if (fullIssue.pull_request) {
                    console.log(`Issue #${issue.number} - Skipping, this is a pull request`);
                    continue;
                  }

                  // Close the issue
                  console.log(`Issue #${issue.number} - Unauthorized, closing`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'not_planned'
                  });

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: CLOSING_COMMENT
                  });
                } catch (error) {
                  console.error(`Error processing issue #${issue.number}: ${error.message}`);
                }
              }
            }

            await processIssues();
